复习
波兰表达式 和 逆波兰表达式
进制转化
判断素数
最大公约数和最小公约数
并查集 （A1107 A1118）
日期相关 ，平年判断，星期几判断，每个月多少天都不一样（要打表的）

================================================================================================
树专题总结

A1020 
根据中序和后序建树
A1086
非递归的中序遍历
A1119
前序和后序进行建树
A1090 A1079 A1094
树的静态存储结构 也就是说树的数组存储方式
A1064
BST对树的遍历
A1076 A1034 
树的DFS和BFS
A1130 
根据二叉树构建序列 ，输出过程是一个前序遍历的过程

================================================================================================
并查集专题
A1107 
根据爱好 构建一个人群，人群是有自己的领袖的，人群也是有自己的人数的

================================================================================================
A1076
主要进行的就是一个广度优先的操作，一个带有深度的广度优先的操作。bfs，或者说是层序遍历操作。
注意审题，本题输入的不是用户的追随者，而是用户本身subscribe的人。

无论是DFS还是BFS，主要的问题都是如果使用一个set进行遍历中插入的话，总是失败啊= =
所以，我觉得还是用结构体比较好，但是我还是觉得多余。

结构体还是很简单的 
struct node{
	int level;
	int id;
	vector<int> adj;
	}Nodes[maxn];

或者是vector<vector<int> >adj;  或者是 vector<int> Adj[maxn];这两种二维数组的表示方式都是可以的

emmmm最后还是按照我原来的方法做出来了，只	不过最后一个测试用例已经超时了。。。。这就很尴尬= =

A1105
主要就是一个快乐模拟的操作。
这个题首先要确定到底长和宽都是多少。
而题目的要求是，尽量让M和N接近的情况下，计算长和宽。
所以，采用一个sqrt的方法进行递减比较。

关于二维数组的结构
使用的是：
vector<vector<int> >b(m,vector<int>(n));
后面的复试操作表示赋值m和vector<int> (n)的东西；
其中vector<int> (n);表示的是n个元素的 vector，相当于是一个维度。

但是这种模拟还是很恶心人= =

A1110
完全二叉树的判断，使用占用空间进行判断，对于N个节点的完全二叉树，占用的空间最大是N，然后空间最大值可以通过遍历辅助得到。
A1111 
图的遍历操作，最短路径

A1112
散列表的应用，你必须使用散列表，一个字母如果第一次出现的时候没有发生故障，而后面看似发生了故障，这就是难点。也就是因为这个，你才必须使用散列表。

A1113
EZ LMAO

A1114 
并查集里面的难题，同样是并查集，A1107和A1118都没有这么难，A1107是最简单的isRoot,father,course就可以解决；A1118容易被迷惑成树也是重要的部分，实际情况是鸟才是重点，鸟群是有自己的领袖的，判断鸟的领袖关系是最重要的。而本题的参数有很多，简直难的上天了。总结一点经验就是，遇到大量参数的题目的时候，首先应该考虑使用结构体进行存储。

反正遇到很多参数的，尤其是带有模拟性质的东西，一定要用结构体和cmp函数(algo)
很简单的题，就是模拟+并查集，模拟的题目，最好就是使用结构体，其实A1114并没有用到几个并查集，无非就是在输入的时候将父亲和自己，自己和母亲，自己和孩子们union在了一起；然后就是把不同的记录进行整合，具体体现的就是将同一个家族的人的数据集中到一个数据集里面。

输入数据——顺便建立father的联系关系———根据联系关系进行二次加工，比如研究研究鸟群的领袖是谁，然后鸟的个数都是多少。
A1114就是根据父亲节点，将data数据集中到家族数据库中。

A1119
二叉树根据后序序列和前序序列输出一个随机的中序序列。
pre 
root  preleft+1 .....i-1 i ....preright
post 
postleft ..... postleft+(i-preleft-1)-1  postleft+ (i-preleft-1) ......postright-1 postright
思路：关键问题就是根节点有几个孩子，如果只有一个孩子，那肯定不是unique，如果有两个或者多个孩子，那肯定unique。
所以，写一个递归函数，由于目标是获取中序序列，所以我们首先遍历左子树，然后将根节点入队，然后遍历右子树。
其中，如何确定左右子树的界限是关键的问题。所以定义的递归函数中有四个参数，分别是preleft preright postleft postright

根据pre的第二个元素是post的倒数第二个元素的规则。我们再pre中寻找post[postright-1]的位置。得到的pre中的位置是i;
之后，根据i-preleft的大小，确定是不是存在左孩子。如果i-preleft <=1 那么根节点肯定只有右孩子（因为我们假定右孩子一定存在，而左孩子可能存在）。如果i-preleft <=1 说明不是unique，如果i-preleft >1 说明存在左孩子。

我们对左孩子序列的遍历操作是getin(preleft+1,i-1,postleft,postleft+(i-preleft-1)-1);
我们对右孩子序列的遍草知识是getin(i,preright,postleft +(i-preleft -1),postright-1);
注意这个两个遍历都去掉了根节点。

A1120 
ez
本质上是计算每一位元素的和，作为id

A1121 
单身狗 
首先输入的是已经结婚的人对，之后输入参加party的人，注意，已经结婚的人，由于其配偶不在，也归属于单身狗行列。
只有两个人都在，才叫做存在。
注意一定要按照格式进行输出，也就是对于00000这种东西，一定要按照printf("%05d",n)进行输出

A1122
哈密顿环（一个包含图中每个顶点的简单循环）
一个是要将全图的所有顶点都遍历过来，一个是要闭合联通路径
所以简单的判断包括了，是不是有N+1个顶点，首尾是不是一致的，然后才是老老实实的做循环和判断。

A1123 判断完全二叉树（A1110） + AVL的修正
判断是不是一个完全的AVL。。。。。AVL首先是一个BST，然后每一个顶点的高度差都要是0或者是1或者是-1;
判断标准——左右子树的高度差小于1，每一个子树都是一个平衡二叉树

分析：这道题实际上考察AVL树和层序遍历两个知识点。
判断是不是完全二叉树（A1110），就看在出现了一个孩子为空的结点之后是否还会出现孩子结点不为空的结点，如果出现了就不是完全二叉树。判断完全二叉树的题之前也碰见过，具体操作是按照N个节点的完全二叉树在数组存储方式中也要占用N个空间来判断的。其实也就是在层序遍历的同时维护一个indice参数。

AVL树一共有四种情况，这里我把发现树不平衡的那个结点叫做A结点，A发现树不平衡的情况有四种：
新来的结点插入到A的左子树的左子树LL —— R
新来的结点插入到A的左子树的右子树LR —— LR
新来的结点插入到A的右子树的左子树RL —— RL
新来的结点插入到A的右子树的右子树RR -- L
发现不平衡时就需要处理，第1种情况只要简单的右旋，第4种情况只需左旋一下，第2种情况需要先对A的左子树左旋一下，然后对A右旋，同理第3种情况需要对A的右子树右旋一下，然后对A左旋，


A1131
DIJ中所有的遍历都是图中的节点个数而不是maxn个。


进制转化
主要的思路就是按照多项式进行转化
base1进制的x转化为base2进制的y
int x;
int y;
int base_x ,base_y = 10;
int product = 1;
int base;
while(x!=0){
	y = y + (x% base_y)*product;
	x = x/ base_y;
	product *= base_x;
}
//首先将P进制的X转化为十进制的Y
x%base_x就是为了获取x的个位情况 
x/base_x就是为了去除x的个位，相当于将x进行了右移
//然后将十进制的Y转化为Q进制的Z
int z[40];
in	t y;
int num = 0;
do{
	//首先是获取y的个位
	z[num++] = y%Q;
	//然后是将y去掉个位，表现就是进行除法
	y =y/Q;
}while(y!=0)

A1124
一般这种涉及到string和int之间映射关系的，使用数组是很傻的，因为你本质上的操作涉及不到string只会涉及到int。所以呢，我个人非常的推荐使用map或者是struct也可以。

注意本题中有些人为了提高自己的中奖率会刷屏==
所以难免还要使用一个set，注意如果这个人已经在set中出现了，那么就选择这个人的下一个人作为winnner

然后就是没有winnner的情况，只有一个，就是参加人数不够第一个winnenr的序号这种情况
注意，一般的find函数返回的是迭代器，而某些特殊的容器，比如说是string，返回的东西可能是size_t格式的位置。
一般来说find返回的是迭代器啊，可以跟container.begin和container.end一起来使用啊！！！！

本题我一开始使用的数据结构map，但是我没想到的是我忘记了相同的key是会映射到相同为位置上的

以后的输入题，都要注意一点，就是scanf()不会处理后面的换行符号，单纯是会将换行符号留在缓冲区里面，
然后如果你下面用的是cin>>string，恭喜你GG；就好比A1124这个题，如果在scanf数字输入之后，使用cin>>string，会因为没有及时处理后面的换行符号，导致cin了一个换行符号，对后面产生了严重影响。
A1125
这应该是一个计算哈夫曼树的题，需要注意的就是，最直观的方法是，将每两个点的数值进行计算，然后做成一个新的节点，之后插入，但是这显然是人的做法，如果究其本质，如果将问题抽象，小数字会被多次计算，而大数字被计算的次数较少。、

这个题，liuchuo的思路是非常简洁的，仿照她做的就行了。


A1126 七桥问题 【odd 奇数，even偶数】
这个题就是从某一个点开始，到这个点结束，准确的访问这个图的每一条边。
It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are called Eulerian. 

If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other.
A graph that has an Eulerian path but not an Eulerian circuit is called semi-Eulerian. 

Given an undirected graph, you are supposed to tell if it is Eulerian, semi-Eulerian, or non-Eulerian.

判断 circuit 和 path 是不是都存在，circuit就是从某一个点开始回到这个点可以遍历每一个边 
如果可以遍历每一个边，但是起点终点不一样，就是semi，
如果无法遍历每一个边，就是non

如果有两个奇数odd度的顶点，就是semi
思路：计算每一个点的度数，然后判断。。。。。
如果odd度点数大于2，就是non
如果odd度代数等于2，就是semi
如果odd度点数小于2，就是full

注意一点——除了计算每一个点的度是奇数还是偶数

A1127 
本题就是一个比较曲折的层序输出的方式罢了，关键的问题就是找到每一层的左边界和右边界。然后输出。或者是借助栈和队列来进行。此外的一个难点就是，根据中序和后序队列进行建树。

