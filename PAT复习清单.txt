复习
波兰表达式 和 逆波兰表达式
进制转化
判断素数
最大公约数和最小公约数
并查集 （A1107 A1118）
日期相关 ，平年判断，星期几判断，每个月多少天都不一样（要打表的）

================================================================================================

A1076
主要进行的就是一个广度优先的操作，一个带有深度的广度优先的操作。bfs，或者说是层序遍历操作。
注意审题，本题输入的不是用户的追随者，而是用户本身subscribe的人。

无论是DFS还是BFS，主要的问题都是如果使用一个set进行遍历中插入的话，总是失败啊= =
所以，我觉得还是用结构体比较好，但是我还是觉得多余。

结构体还是很简单的 
struct node{
	int level;
	int id;
	vector<int> adj;
	}Nodes[maxn];

或者是vector<vector<int> >adj;  或者是 vector<int> Adj[maxn];这两种二维数组的表示方式都是可以的

emmmm最后还是按照我原来的方法做出来了，只不过最后一个测试用例已经超时了。。。。这就很尴尬= =

A1105
主要就是一个快乐模拟的操作。
这个题首先要确定到底长和宽都是多少。
而题目的要求是，尽量让M和N接近的情况下，计算长和宽。
所以，采用一个sqrt的方法进行递减比较。

关于二维数组的结构
使用的是：
vector<vector<int> >b(m,vector<int>(n));
后面的复试操作表示赋值m和vector<int> (n)的东西；
其中vector<int> (n);表示的是n个元素的 vector，相当于是一个维度。

但是这种模拟还是很恶心人= =

A1110
完全二叉树的判断，使用占用空间进行判断，对于N个节点的完全二叉树，占用的空间最大是N，然后空间最大值可以通过遍历辅助得到。
A1111 
图的遍历操作，最短路径

A1112
散列表的应用，你必须使用散列表，一个字母如果第一次出现的时候没有发生故障，而后面看似发生了故障，这就是难点。也就是因为这个，你才必须使用散列表。

A1113
EZ LMAO

A1114 
并查集里面的难题，同样是并查集，A1107和A1118都没有这么难，A1107是最简单的isRoot,father,course就可以解决；A1118容易被迷惑成树也是重要的部分，实际情况是鸟才是重点，鸟群是有自己的领袖的，判断鸟的领袖关系是最重要的。而本题的参数有很多，简直难的上天了。总结一点经验就是，遇到大量参数的题目的时候，首先应该考虑使用结构体进行存储。

反正遇到很多参数的，尤其是带有模拟性质的东西，一定要用结构体和cmp函数(algo)
很简单的题，就是模拟+并查集，模拟的题目，最好就是使用结构体，其实A1114并没有用到几个并查集，无非就是在输入的时候将父亲和自己，自己和母亲，自己和孩子们union在了一起；然后就是把不同的记录进行整合，具体体现的就是将同一个家族的人的数据集中到一个数据集里面。

输入数据——顺便建立father的联系关系———根据联系关系进行二次加工，比如研究研究鸟群的领袖是谁，然后鸟的个数都是多少。
A1114就是根据父亲节点，将data数据集中到家族数据库中。

A1119
二叉树根据后序序列和前序序列输出一个随机的中序序列。
pre 
root  preleft+1 .....i-1 i ....preright
post 
postleft ..... postleft+(i-preleft-1)-1  postleft+ (i-preleft-1) ......postright-1 postright
思路：关键问题就是根节点有几个孩子，如果只有一个孩子，那肯定不是unique，如果有两个或者多个孩子，那肯定unique。
所以，写一个递归函数，由于目标是获取中序序列，所以我们首先遍历左子树，然后将根节点入队，然后遍历右子树。
其中，如何确定左右子树的界限是关键的问题。所以定义的递归函数中有四个参数，分别是preleft preright postleft postright

根据pre的第二个元素是post的倒数第二个元素的规则。我们再pre中寻找post[postright-1]的位置。得到的pre中的位置是i;
之后，根据i-preleft的大小，确定是不是存在左孩子。如果i-preleft <=1 那么根节点肯定只有右孩子（因为我们假定右孩子一定存在，而左孩子可能存在）。如果i-preleft <=1 说明不是unique，如果i-preleft >1 说明存在左孩子。

我们对左孩子序列的遍历操作是getin(preleft+1,i-1,postleft,postleft+(i-preleft-1)-1);
我们对右孩子序列的遍草知识是getin(i,preright,postleft +(i-preleft -1),postright-1);
注意这个两个遍历都去掉了根节点。

A1120 
ez
本质上是计算每一位元素的和，作为id

A1121 
单身狗 
首先输入的是已经结婚的人对，之后输入参加party的人，注意，已经结婚的人，由于其配偶不在，也归属于单身狗行列。
只有两个人都在，才叫做存在。
注意一定要按照格式进行输出，也就是对于00000这种东西，一定要按照printf("%05d",n)进行输出

A1122
哈密顿环（一个包含图中每个顶点的简单循环）
一个是要将全图的所有顶点都遍历过来，一个是要闭合联通路径
所以简单的判断包括了，是不是有N+1个顶点，首尾是不是一致的，然后才是老老实实的做循环和判断。

A1123 判断完全二叉树（A1110） + AVL的修正
判断是不是一个完全的AVL。。。。。AVL首先是一个BST，然后每一个顶点的高度差都要是0或者是1或者是-1;
判断标准——左右子树的高度差小于1，每一个子树都是一个平衡二叉树

分析：这道题实际上考察AVL树和层序遍历两个知识点。
判断是不是完全二叉树（A1110），就看在出现了一个孩子为空的结点之后是否还会出现孩子结点不为空的结点，如果出现了就不是完全二叉树。判断完全二叉树的题之前也碰见过，具体操作是按照N个节点的完全二叉树在数组存储方式中也要占用N个空间来判断的。其实也就是在层序遍历的同时维护一个indice参数。

AVL树一共有四种情况，这里我把发现树不平衡的那个结点叫做A结点，A发现树不平衡的情况有四种：
新来的结点插入到A的左子树的左子树LL —— R
新来的结点插入到A的左子树的右子树LR —— LR
新来的结点插入到A的右子树的左子树RL —— RL
新来的结点插入到A的右子树的右子树RR -- L
发现不平衡时就需要处理，第1种情况只要简单的右旋，第4种情况只需左旋一下，第2种情况需要先对A的左子树左旋一下，然后对A右旋，同理第3种情况需要对A的右子树右旋一下，然后对A左旋，


A1131
DIJ中所有的遍历都是图中的节点个数而不是maxn个。