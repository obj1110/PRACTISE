1. 关于printf中%02d和%0.2f分别是两位整数和两位小数的输出。

vector<int> array(num,0);
  for(int i=0;i<num;i++){
    scanf("%d",&(array[i]));
  }
vector中的东西要是想要输入，依旧要使用地址
学会使用容器迭代器，vector.begin() vector.end()

2. 学会使用这个struct
比如说学生有学号又有座位号成绩等等，就可以声明一个结构体专门用于存放这个学号、座位号、结构体等等。
然后，又比如一个镇上的人年龄，可以专门创建一个结构体存放姓名和生日等等。

3. 字符数组变量的相互赋值依靠的是strcpy(destination,source)

4. 进制转化模板
int x,int base;
scanf("%d%d",&x,&base);
int y[40],int count=0;
while(x!=0){
	y[count++] = x%base;
	x = x/base;
}

5. 简易的映射模板通过char[]数组就可以建立，而更加复杂的映射模板包括了高级STL应用。map和unorder_map。

6.对于特殊情况的输入，可以考虑cin。

7. pat的字符串题，需要考虑本身输入的东西对不对，这样可以极大地简化计算，比如，你有的身份证号可能黑盒测试输入的是a b之类的东西，所以你要首先判断输入的东西是不是符合你的算法。

8. 数组长度的获取（char数组直接用strlen就行了） C、C++中没有提供直接获取数组长度的函数，对于存放字符串的字符数组提供了一个strlen函数获取长度，那么对于其他类型的数组如何获取 长度呢？其中一种方法是使用sizeof(array)/sizeof(array[0]),?在C语言中习惯上在?使用时都把它定义成一个宏，比如#define GET_ARRAY_LEN(array,len){len=(sizeof(array)/sizeof(array[0]));}?。而在C++中则可以使用模板 技术定义一个函

9. 关于字符串的输入，比如一句有很多个单词和空格组成的英文句子
char word[80][80]
可以采用while(scanf("%s",word[i])!=EOF) 这种方式进行输入
也就是采用二维数组进行存储，然后采用一个eof进行判断

当然另外一种方式就是用cin 或者是 gets全部进行读取，然后进行字符串按照空格的分割。

涉及到string类的两个函数find和substr
不涉及STL的，用strtok函数进行字符串分割

10. 对于char数组的长度，你可以用sizeof(char )/sizeof(char[0]) 的形式，似乎也可以用strlen进行计算。
而一般的数组的长度都要用一个sizeof/sizeof方法
STL容器的大小也可以sizeof/sizeof方法

11. 注意char元素和int元素
str1[i-1] = (str2[i-1] - str1[i-1])>=0?(str2[i-1]-str1[i-1]+'0'):(str2[i-1]-str1[i-1]+10+'0'); 
比如我的str1数组是一个char数组，但实际上，str2[i-1]-str1[i-1]之间的差不是一个char类型的东西，所以要加上'0';


12. 注意字符串数组不是string而是char的二维数组

13. 关于堆栈的使用我们可是曾经学过啊，使用一个数组结合一个指针来模拟堆栈。

14. 有些剪枝操作是必不可少的，必须留着

15. strcmp的使用前提是对于这个const char*类型的元素。所以有些时候char []中的元素无法参与比较。而是要用双等号来比较。
同样的strcpy的使用也是需要const char*类型的元素，所以有些时候char[] 中的元素无法参与赋值。而是要用等号赋值。

16. scanf对于char[]数组类型的读取并不需要使用&符号，而是使用数组名即可。

17. 对于reverse的使用目前见到过三种形式，一种是reverse(array.begin(),array.end());
一种是reverse(begin(array),end(array));
还有一种是reverse(array,array+strlen(array));

18. 
strcpy(destination,source)
strnpy(destination,source,size_t n) 也就是将指定的n个字符移动到某一个位置

substr函数
string substr(size_t pos =0, size_t len = npos) const;

find函数
std::string str = str2.find(3,5); //将一个子串赋值给一个新串

对于一行一行的数据的读取
在大型的while循环中，getchar()读取的是换行符，然后使用gets来读取一行，直到换行符/n为止
for(int i=0;i<n;i++){
	getchar();//
	gets(array_name);
}

cin.getline(array_name,size_t end_position,'/');
也就是三个参数，一个是数组的名字，一个是未知，一个是换行标志,这是一种文件流读取方式
char ch[20];
cout<<"enter a sentence:"<<endl;
cin>>ch;
cout<<"The string read with cin is:"<<ch<<endl;
cin.getline(ch,20,'/');  //读个字符或遇'/'结束
cout<<"The second part is:"<<ch<<endl;
cin.getline(ch,20);  //读个字符或遇'/n'结束
cout<<"The third part is:"<<ch<<endl;

19. 字符读取函数
1、cin 
2、cin.get() 
3、cin.getline() 
4、getline() 
5、gets() 
6、getchar()

附:cin.ignore();cin.get()//跳过一个字符,例如不想要的回车,空格等字符

cin 遇“空格”、“TAB”、“回车”都结束  /b /t /n

cin.get(char_name)
cin.getchar(char[]_name,size_t n) 可以接收空格

cin.get() 相当于是无参数的getchar

cin.getline(char[]_name,size_t n)   // 接受一个字符串，可以接收空格并输出,默认的3号参数是/n

getline()     // 接受一个字符串，可以接收空格并输出，需包含“#include<string>”



第一种：?在<istream>中的getline()函数有两种重载形式：

istream& getline (char* s, streamsize n );
istream& getline (char* s, streamsize n, char delim );

作用是：?从istream中读取至多n个字符(包含结束标记符)保存在s对应的数组中。即使还没读够n个字符，

std::cin.getline(name, 6, '#');
将输入流输入到name数组中，然后读取长度为6个或者读取到了'#'

如果遇到delim或字数达到限制，则读取终止，delim都不会被保存进s对应的数组中

第二种：?在<string>中的getline函数有四种重载形式：【STL】

istream& getline (istream& ?is, string& str, char delim);
istream& getline (istream&& is, string& str, char delim);
istream& getline (istream& ?is, string& str);

istream& getline (istream&& is, string& str);
用法和上第一种类似，但是读取的istream是作为参数is传进函数的。读取的字符串保存在string类型的str中。
--------------------- 


(EOF是C语言中为了区分有效数据和输入结束符的。

EOF的输入由系统锁定。windows下是ctrl+z,linux/unix下是ctrl+d。)

getline不是C库函数，而是C++库函数。它遇到以下情况发生会导致生成的本字符串结束：

(1)到文件结束，(2)遇到函数的定界符，(3)输入达到最大限度。


gets本身是一个C的函数，所以在C11中被替换为fgets

20。 substr一定是要用两个size_t作为参数，而且可以用find进行辅助寻找位置


21.
char num[12];
strcpy(num,'a'); 非法
strcpy(num,temp); 合法

22. 对结构体数组的快速定义
struct student{
	int chinese;
	int math;
	int english;
	char id[20];
}Students[1010];这种快速定义的犯法

23. 排序题必须做的就是引入algorithm和主动构造一个排序函数cmp函数，而且这种题一般都是要定义结构体数组的。
emmmmm不过目前并不明确，如果说要升序的话该怎么办。

24. 注意C++的编译器对于== 还是=不会作出明确的反馈，也就是说，有些错误明确的就是因为本来应该用=的地方用了==，然后就错了。
GCC不会对这种错误做任何的反映。务必最高注意！！

25. PAT的测试大多数都是要求最后不能出现空格或者换行符之类的东西的，所以你要特别注意啊

26.     //实践证明，这种说法还是很有用也是很可行的。 
    else return strcmp(a.id,b.id)<0; 
	字符数组的比较必须要用到strcmp这种感觉的东西，而对于字符串的比较就可以直接用大于小于。
	
1234567890001 95
1234567890005 100
1234567890003 95
1234567890002 77
1234567890004 85

这种字符串的比较就是可以用strcmp来比较


27. int 可以表示的范围至少是2*10的10次方这么大的东西。
所以如果数据最多是一个9位的整数或者是一个1*10^10，你完全是可以用int的

28. 特别注意！！！！！
if(stu[i].id == a) 和 if(strcmp(stu[i].id,a))这两种情况，以后所有的字符串比较，所有的字符串比较，优先使用strcmp而不是那个狗屎==号！！！！



29. 调用sort()排序是最好的结果，目前的能力，解决1029很难。

30. 字符数组的元素的scanf是要求你使用scanf("%s",array_name[i])
而数字数组的元素的scanf要求你使用scanf("%d",&array_name[i]);


31. （1）itoa函数――――――――功能：把一整数转换为字符串
2）atoi函数――――功能：把字符串转换成整型

32. 在C11中，变成了std::to_string
std::string =  std::to_string(number);

strlen(const char* ) 
C11中的string专门STL的容器，应该使用.Length()属性进行查看

33. 一旦涉及到了对于cmp函数的定义，那重点一定是sort的构造和使用

34. 做不出来的时候，首先按照暴力进行求解，别告诉我是dp问题

35. string.erase(size_t a,size_t b);

string& erase (size_t pos = 0, size_t len = npos);
也就是从a的位置开始移除b长度的数组


36. 关于string.strlen()和string.size()的情况
.size()是STL容器函数
.length()是string专属函数

min[0] == "0" 编译错误，因为min[0]是字符不是字符串
min[0] == '0' 对

37.
pat的套路比如说哪种根据提交情况很多条记录来最后汇总的（A1075）
要注意提交记录是从1号问题开始提交的，而不是从0号问题开始提交的


38. 关于A1075这个题
这个题分为提交和未提交两种，提交的要不就是0分，要不就是正分
但是没提交的问题，肯定是-1

所以要求你对数据结构的设置非常明确

此外要统计好perfect和fail的情况

同时，每次输入一个记录都要求你自己要明确的知道原来的结构体数组中有没有，当然是需要进行for循环遍历操作了

最后要明确的是cmp函数
如果你最后的排序结果要求分数递减，那就return a.score>b.score
如果你要求id按照字母顺序递增
那就 return a.id<b.id 
或者 return strcmp(a.id,b.id)<0

39. 用数组初始一个vector
vector<int> index(array,array+n);
vector.begin .end返回的是开始和结束位置的两个指针 
.front .rear返回的是开始和结束为止的元素的值

而对于数组没有，数组只有array,array+N
对于一般的数组长度还要用sizeof/sizeof(array[0])来计算，对于字符数组可以用strlen来进行操作

40. char array[10][20] 和 string array[10]作用相同，但是相关的调用函数并不一样

41.数组元素赋值操作：
memset

实践证明length或者是length()不适用于数组
sizeof函数返回的是一个变量的字符数
memset只用于给数组赋值为0或者是赋值为-1，所以这就是个弟弟

int array[5] = {-2}能做的仅仅是把第一个元素赋值为-2，而={}或者={0}可以把所有的元素赋值为0

42. scanf中的%s的功能是对空格或者是换行符进行识别，而%c对于空格或者是换行并不敏感

43.
vector为变长数组，比较节省空间

对于vector中存的时内置类型的数据，如int，char，因为vector已经重载了“==”   、“！=”、  “<=”、 “>=”、 “<”、 “>”运算符，所以可以直接将两个vector用这些运算符比较。

区别.size和 sizeof这两种东西:
.size是STL标准 sizeof函数返回的是一个变量的字符数

memset是对于所有的字节进行赋值，应该说其参数和正常情况并不一样，而是完全不对应的一个东西。因为是字节赋值，所以直接用sizeof(数组名)就行了


getchar应该是一个一个字符的进行输入，然后可以用getchar来吸收换行，但是似乎getchar也会接收空格

空字符的长度为0,空格符的长度为1
char a[] = "\0";
char b[] = " ";
cout << strlen(a) << endl;   //0
cout << strlen(b) << endl;   //1

//空格是" "，空字符是\0 或 null

使用getchar进行字符的输入一定要在最后的位置加上一个/0
使用gets或者是scanf就可以不用管了，照常处理就行了。


40. cstring__其实更多的是对于char item[10]的操作
包括strlen strcmp strcat(char array1[10],char array2[10]) 和 strcpy(destination,source)
还有就是传统的字符串转换函数也就是sscanf和 sprintf其实这两个不是输入输出函数而是字符串转化函数

char array[100];
int n;
//从左到右
cin>>array;
scanf("%s",array);  

//从右到左
cout<<n<<endl;
printf("%d",n);

//从左到右，将array中的东西以%d写入到n中
sscanf(array,"%d",n);
//从右到左，将n以%d的格式写入到array中
sprintf(array,"%d",n);
/////////////////////////////////////////////////////////////////////
	char array[100]="123456789";
	int n;
	
	sscanf(array,"%d",n);
	printf("%d",n);
	
	sprintf(str,"%d",n);
	printf("%s",str);
/////////////////////////////////////////////////////////////////////

sscanf将string转化为别的
sprintf将别的总成为stirng

需要注意的就是sscanf和scanf一样都是需要加上大量的&符号的


41. 指针
指针变量赋值使用的一定是地址，也就是变量的名字加上&符号取地址。
int* array = &val_array;同时数组名也是数组第一个元素的指针的名字也就是说
int array[10] -----> array = &a[0]; array这个名字本身就是指向第一个变量的指针



	三种参数传递方式，引用传递参数和指针传递参数和变量传递参数
	其中引用传递参数的时候
	void swap(int *a,int *b){
		int x;
		int* temp = &x;
		*temp =*a;
		*a= *b;
		*b = *temp;
		
	}
	
	对pointer赋值等于改变指针指向
	对*pointer赋值等于改变指针指向的地址的内容

42. 指针与数组
array+i其实也是一种地址
所以，scanf("%d",a+i);就可以给第i个元素进行赋值，而不需要使用scanf("%d",&a[i]);

由于指针变量的自增操作，可以
for(int *i =array; i< a+10;i++) printf("%d",*i);
	其中i本身和a+10都是地址可以进行比较的
	
struct item{
	int id;
	char name[20];
	//四大构造函数 
	stu(){};
	stu(int _id,char _name[20]){
		id = _id;
		strcpy(name,_name);
	}
	stu(int _id){
		id = _id;
	}
	stu(char _name[20]){
		strcpy(name,_name);
	}
}stu;

简化构造函数
struct_type_name(parameter):struct_item1(_paramter1),struct_item2(_paramter2){};

struct item2{
	int id;
	char name;
//	item2(int _id,char _name):id(_id),name(_name){};
	item2(int _id,char _name){
		id = _id;
		name = _name; 
	}
}; 

struct struct_type{}
在main里面就可以声明struct_type创建一个struct变量了。
#include<iostream>
using namespace std;
struct point{
	int x;
	int y;
	//极其简化的构造函数 
	point(int _x,int _y):x(_x),y(_y){};
};
int main() {
	point pts = point(10,20);
	cout<<pts.x<<" "<<pts.y<<endl;
}

43. .string里主要是对于char[]处理的函数，而本身的string是STL函数，比如说是erase 和 size之类的。

cstring属于C库 string属于STL模板 还有cstdlib【C标准库】


cstdlib中的函数包括了:
atoi atol atof atoll 
strtod strtol strtof strtold strtoll strtoul strtoull
free malloc
rand srand 

cstring中的函数包括了：
memset
strcat strcpy strcmp 
size_t【一种由size_t返回的unsigned int类型】

还是强调sscanf和sprintf，前者负责拆分字符串，后者负责合并字符串。非常重要。memset负责对整个数组按照字节进行赋值，一般使用0或者是-1，特殊情况使用1.


对于无标志读入字符串，有两种方式，分别是
while(scanf("%s",str)!=EOF)
和 while(gets(str)!=NULL) + getchar

gets本身会吸收最后的换行符号，所以一般不需要再次使用getchar
而scanf不会处理空格和换行相反会用二者作为截止的标志，所以我们应该讲getchar和scanf进行搭配。

1.scanf输入字符串的时候不会接收Space空格，回车Enter，Tab键，则认为输入结束。【不处理回车，空格】
2.gets能接收空格键，回车键，Tab键，回车则认为输入结束                       【处理回车，空格】
3.getchar只能接受一个字符，遇到回车结束输入，可接受回车键。常用来吸收回车符 【可以吸收回车】

包括cin和scanf都是从数据流中读取数据的，所以说，如果数据缓冲区中残存上次没有读完的\n之类的东西，就会让scanf直接结束，因而我们非常需要的就是使用getchar读取输入。

1.scanf（）用%c，%s空格键，Tab键，回车键结束一次输入，不会舍弃最后的回车符或空格或Tab（即还在缓冲区中），可使用getchar来吸收scanf()执行之后的换行符。
2.getchar（）以回车键结束，也不会舍弃回车符（即存入缓存区）
3.gets（）以换行符结束，但之后会舍弃换行符并以'\0',代替(意思是'\n'不会被代入到字符数组中，也不会将换行符存入到缓存区)也就是说：gets()函数读取到\n（我们输入的回车）于是停止读取，但是它不会把\n包含到字符串里面去。然而，和它配合使用的puts函数，却在输出字符串的时候自动换行。

然后字符数组的最后结束标志就是一个空字符也就是0号Asc   \0
gets的原理就是把读进来的/n替换为/0之类的东西。而scanf虽然不会处理掉/n，但是对于读取进来的东西一样会在最后加上一个\0

scanf不会处理换行/n 和 空格32 ，但是以回车/r为结束标志
gets会处理/n和空格，但是一样以回车/r为结束标志  二者都是回车结束

scanf返回的是成功读取的参数的个数，如果没有读取到就返回-1.而对于EOF来说，EOF就是-1.所以while(scanf("%d",&n)!=EOF)就可以实现字符的读取工作。

最简单的说法，scanf要用getchar处理结尾的换行，scanf自己会处理回车，scanf以空格为结束标志
gets一直读取到换行符号位置，自己处理很多东西，然后可以读取带有空格的字符串


44. 最容易出现的错误，本来应该printf的位置你进行了scanf操作



ASCII的小写比大写要大32.。。。。。

A1084的思想就是：
对于str1中的每一个元素，都在str2中进行寻找，如果找到了，那就继续遍历str1的下一个，如果没有找到，就输出。
此外，在遍历str2的时候，将str2的所有的字母元素全部变成大写就行了。


对于B1033你要明确的知道一件事情就是：大写字母的成功输出，一个是需要小写字母，一个是需要上挡。
此外，你第一个字符串所谓的大写字母坏了，说明小写字母一定是坏了。当然如果26个大写字母的话，那可能是上挡坏了。

memset对于int数组只有0和-1是正确的结果
memset对于bool数组似乎是true和false都行
memset的用法
memset(array,value,sizeof(array));

因为你的这个bool数组都是1byte大小的数据所以当然true和false都可以的了。


所谓的字符串散列说到底也就是一个固定在0~128之间的一个标志数组。


#include<cmath>
ceil
floor 
round (四舍五入)
fabs  计算浮点数绝对值
abs 整数绝对值

#include<cstring>是包含了string.h库
而#include<string>包含的是STL

gets可以直接读取一行，读到换行为止，不管什么空格，
但是很遗憾的是C++中无法直接使用
所以使用scanf？？也不可以读取空格
cin？？？也不可以读取空格

char *gets_s(char *str, rsize_t n);  C11 
char * fgets ( char * str, int num, FILE * stream );

而gets功能最像的就是cin.getline();
cin.getline(s1, 100000); 有两种停止方式一个是读取到换行，一个是读取到了100000个

所以这么说来，其实gets_s也是两种方式的停止方式

45. 四大输入函数
纯cin 输入一行 遇到空格 换行结束
scanf 输入空格 或者是换行结束
cin.get(char_name) 用来接收字符
 ch = cin.get() 或者 cin.get(ch) ----接收字符
 cin.get(char array[],int n)-------接收一个字符数组
 注意cin.get是可以接收空格的，所以有两种结束方式一个是读取到规定长度的数组，另外一个是读取到换行符号
 
 和cin.getline()类似，但是cin.getline()属于istream流，而getline()属于string流，STL
 
 cstring 处理char[],string 属于STL
 
 PAT大忌就是说你把== 错写成了= 或者是颠倒了过来，这个问题就是说编译器不报错，这个问题不是一次两次了。
 
 A1048的特例就是说，如果需要两个一样大小的硬币的时候，你就需要判断是不是是不是真的有两个。所以hash数组要声明为int类型而不是bool类型的。
 
 1048为何会产生段错误？很简单，你虽然硬币最大是500的，但是你很大几率会涉及到大于500的面额，这个时候虽然是不存在的，但是你会默认去访问hash[m-i]这个是时候就是数组段错误了。解决办法有两个，一个是用大的hash数组，另一个是用if循环对m-i进行判断，一定要小于500
 
 
 分治
 递归 不断调用自己
 回溯 递归的剪枝操作
 迭代 循环操作
 
45
N皇后的问题就是递归全排列问题，但是不同的hashTable的作用不同。在全排列里面表示哪一个数字已经被使用了。但是在N皇后里面表示哪一行已经有皇后了。

46 
cin.get(char_name);
char_name = cin.get();

cin.getline(array_name,maxsize);
cin.get(array_name,maxsize);

cin.get(NULL);  //专门用于接收空格。

upper_bound和lower_bound的使用
lower_返回的是第一个>=key的指针，这个元素不比key小
upper_返回的是第一个<key的指针，这个元素大于key。
如果想要获取位置，要减去array这个数组,得到int

lower_bound
三种返回结果，一种是0，也就是所有的元素都大于等于你的key，一种是不越界的位置，最后一种是last越界位置，表示所有的值都小于你的key值。
upper_bound返回查找元素的第一个可安插位置，也就是“元素值>查找值”的第一个元素的位置
这两个函数都是基于二分查找的。并且查找区间左闭右开。

lower_bound( array_name+lower_bound , array_name+upper_bound ,key值)

binary_search(int array[],int size,int key) STL二分查找模板，最后返回middle或者是返回-1(没找到)